/* Generated by RForth compiler */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>

#define DEFAULT_STACK_SIZE 256
#define RETURN_STACK_SIZE 256

/* Runtime stacks */
static int64_t stack[DEFAULT_STACK_SIZE];
static int64_t return_stack[RETURN_STACK_SIZE];
static int sp = -1;
static int rsp = -1;
static int64_t *variables[1000];
static int var_count = 0;
static char input_buffer[1024];
static int input_pos = 0;

static void push(int64_t value) {
    if (sp < DEFAULT_STACK_SIZE - 1) stack[++sp] = value;
}

static int64_t pop(void) {
    return (sp >= 0) ? stack[sp--] : 0;
}

static void rpush(int64_t value) {
    if (rsp < RETURN_STACK_SIZE - 1) return_stack[++rsp] = value;
}

static int64_t rpop(void) {
    return (rsp >= 0) ? return_stack[rsp--] : 0;
}

static void forth_dot(void) {
    printf("%ld ", (long)pop());
}

static void forth_emit(void) {
    printf("%c", (char)pop());
}

static void forth_cr(void) {
    printf("\n");
}

static void forth_space(void) {
    printf(" ");
}

static void forth_spaces(void) {
    int64_t n = pop();
    for(int i = 0; i < n; i++) printf(" ");
}

static void forth_dup(void) {
    if (sp >= 0) push(stack[sp]);
}

static void forth_drop(void) {
    if (sp >= 0) sp--;
}

static void forth_swap(void) {
    if (sp >= 1) { int64_t tmp = stack[sp]; stack[sp] = stack[sp-1]; stack[sp-1] = tmp; }
}

static void forth_over(void) {
    if (sp >= 1) push(stack[sp-1]);
}

static void forth_rot(void) {
    if (sp >= 2) {
        int64_t c = pop(), b = pop(), a = pop();
        push(b); push(c); push(a);
    }
}

static void forth_2dup(void) {
    if (sp >= 1) { push(stack[sp-1]); push(stack[sp-1]); }
}

static void forth_2drop(void) {
    if (sp >= 0) sp--; if (sp >= 0) sp--;
}

static void forth_to_r(void) {
    rpush(pop());
}

static void forth_r_from(void) {
    push(rpop());
}

static void forth_r_fetch(void) {
    if (rsp >= 0) push(return_stack[rsp]);
}

static void forth_add(void) {
    int64_t b = pop(), a = pop(); push(a + b);
}

static void forth_sub(void) {
    int64_t b = pop(), a = pop(); push(a - b);
}

static void forth_mul(void) {
    int64_t b = pop(), a = pop(); push(a * b);
}

static void forth_div(void) {
    int64_t b = pop(), a = pop(); if(b) push(a / b);
}

static void forth_mod(void) {
    int64_t b = pop(), a = pop(); if(b) push(a % b);
}

static void forth_abs(void) {
    int64_t a = pop(); push(a < 0 ? -a : a);
}

static void forth_negate(void) {
    push(-pop());
}

static void forth_equals(void) {
    int64_t b = pop(), a = pop(); push(a == b ? -1 : 0);
}

static void forth_not_equals(void) {
    int64_t b = pop(), a = pop(); push(a != b ? -1 : 0);
}

static void forth_less_than(void) {
    int64_t b = pop(), a = pop(); push(a < b ? -1 : 0);
}

static void forth_greater_than(void) {
    int64_t b = pop(), a = pop(); push(a > b ? -1 : 0);
}

static void forth_zero_equals(void) {
    push(pop() == 0 ? -1 : 0);
}

static void forth_zero_less(void) {
    push(pop() < 0 ? -1 : 0);
}

static void forth_zero_greater(void) {
    push(pop() > 0 ? -1 : 0);
}

static void forth_and(void) {
    int64_t b = pop(), a = pop(); push(a & b);
}

static void forth_or(void) {
    int64_t b = pop(), a = pop(); push(a | b);
}

static void forth_xor(void) {
    int64_t b = pop(), a = pop(); push(a ^ b);
}

static void forth_invert(void) {
    push(~pop());
}

int main(int argc, char *argv[]) {
    (void)argc; (void)argv;

    word_from();
    word_compiled();
    word_rforth();
    forth_cr();
    push(5);
    push(7);
    forth_add();
    forth_dot();
    forth_cr();
    exit(0);

    return 0;
}
