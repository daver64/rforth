#include "turnkey.h"
#include "compiler.h"
#include "io.h"
#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#ifndef _WIN32
    #include <sys/wait.h>
    #include <unistd.h>
#else
    #include <process.h>
#endif

/* Helper function to convert Forth word name to C identifier */
static void word_name_to_c_identifier(const char *forth_name, char *c_name, size_t size) {
    if (!forth_name || !c_name || size == 0) return;
    
    size_t i = 0, j = 0;
    while (forth_name[i] && j < size - 1) {
        if (forth_name[i] == '-') {
            c_name[j++] = '_';
        } else if (isalnum(forth_name[i])) {
            c_name[j++] = (char)tolower(forth_name[i]);
        }
        /* Skip other characters */
        i++;
    }
    c_name[j] = '\0';
}

/* TURNKEY implementation */

bool turnkey_generate_dictionary_code(FILE *output, dict_t *dict) {
    if (!output || !dict) return false;
    
    /* Generate C code for all user-defined words in the dictionary */
    word_t *current = dict->latest;
    
    while (current) {
        if (current->type == WORD_USER && current->code.definition) {
            /* Convert word name to C identifier */
            char c_name[MAX_WORD_LENGTH];
            word_name_to_c_identifier(current->name, c_name, sizeof(c_name));
            
            fprintf(output, "/* User word: %s */\n", current->name);
            fprintf(output, "static void word_%s(void) {\n", c_name);
            
            /* Here we need to parse and compile the definition */
            /* For now, we'll generate a simple version */
            fprintf(output, "    /* Definition: %s */\n", current->code.definition);
            
            /* TODO: Parse the definition and generate proper C code */
            /* This is a simplified version - real implementation would need */
            /* to parse the Forth definition and generate corresponding C code */
            
            fprintf(output, "}\n\n");
        }
        current = current->next;
    }
    
    return true;
}

bool turnkey_generate_stack_code(FILE *output, rforth_stack_t *stack) {
    if (!output || !stack) return false;
    
    /* Generate initialization code for any values on the stack */
    int depth = stack_depth(stack);
    if (depth > 0) {
        fprintf(output, "    /* Initialize stack with current values */\n");
        for (int i = 0; i <= stack->sp; i++) {
            if (stack->data[i].type == CELL_INT) {
                fprintf(output, "    push_int(%ld);\n", (long)stack->data[i].value.i);
            } else {
                fprintf(output, "    push_float(%.6g);\n", stack->data[i].value.f);
            }
        }
        fprintf(output, "\n");
    }
    
    return true;
}

bool turnkey_create_executable(rforth_ctx_t *ctx, const char *output_file) {
    if (!ctx || !output_file) return false;
    
    /* Generate C filename */
    char c_filename[MAX_FILENAME_LENGTH];
    snprintf(c_filename, sizeof(c_filename), "%s%s", output_file, C_FILE_EXTENSION);
    
    /* Open C file for writing */
    FILE *c_file = fopen(c_filename, "w");
    if (!c_file) {
        io_error_string("Error: Cannot create C file for TURNKEY executable\n");
        return false;
    }
    
    /* Generate C file header */
    fprintf(c_file, "/* Generated by RForth TURNKEY */\n");
    fprintf(c_file, "#include <stdio.h>\n");
    fprintf(c_file, "#include <stdlib.h>\n");
    fprintf(c_file, "#include <stdint.h>\n\n");
    
    /* Generate configuration constants */
    fprintf(c_file, "/* Configuration constants */\n");
    fprintf(c_file, "#define DEFAULT_STACK_SIZE %d\n\n", DEFAULT_STACK_SIZE);
    
    /* Generate runtime stack */
    fprintf(c_file, "/* Runtime stack */\n");
    fprintf(c_file, "static int64_t stack[DEFAULT_STACK_SIZE];\n");
    fprintf(c_file, "static int sp = -1;\n\n");
    
    /* Generate stack operations */
    fprintf(c_file, "static void push(int64_t value) {\n");
    fprintf(c_file, "    if (sp < 255) stack[++sp] = value;\n");
    fprintf(c_file, "}\n\n");
    
    fprintf(c_file, "static int64_t pop(void) {\n");
    fprintf(c_file, "    return (sp >= 0) ? stack[sp--] : 0;\n");
    fprintf(c_file, "}\n\n");
    
    /* Generate I/O functions */
    fprintf(c_file, "static void forth_dot(void) {\n");
    fprintf(c_file, "    printf(\"%%ld \", (long)pop());\n");
    fprintf(c_file, "}\n\n");
    
    fprintf(c_file, "static void forth_emit(void) {\n");
    fprintf(c_file, "    printf(\"%%c\", (char)pop());\n");
    fprintf(c_file, "}\n\n");
    
    fprintf(c_file, "static void forth_cr(void) {\n");
    fprintf(c_file, "    printf(\"\\n\");\n");
    fprintf(c_file, "}\n\n");
    
    /* Generate stack manipulation functions */
    fprintf(c_file, "static void forth_dup(void) {\n");
    fprintf(c_file, "    if (sp >= 0) push(stack[sp]);\n");
    fprintf(c_file, "}\n\n");
    
    fprintf(c_file, "static void forth_drop(void) {\n");
    fprintf(c_file, "    if (sp >= 0) sp--;\n");
    fprintf(c_file, "}\n\n");
    
    fprintf(c_file, "static void forth_swap(void) {\n");
    fprintf(c_file, "    if (sp >= 1) {\n");
    fprintf(c_file, "        int64_t tmp = stack[sp];\n");
    fprintf(c_file, "        stack[sp] = stack[sp-1];\n");
    fprintf(c_file, "        stack[sp-1] = tmp;\n");
    fprintf(c_file, "    }\n");
    fprintf(c_file, "}\n\n");
    
    /* Generate dictionary words */
    if (!turnkey_generate_dictionary_code(c_file, ctx->dict)) {
        fclose(c_file);
        return false;
    }
    
    /* Generate main function */
    fprintf(c_file, "int main(int argc, char *argv[]) {\n");
    fprintf(c_file, "    (void)argc; (void)argv;\n\n");
    
    /* Initialize stack with current state */
    turnkey_generate_stack_code(c_file, ctx->data_stack);
    
    fprintf(c_file, "    /* TURNKEY executable - current interpreter state preserved */\n");
    fprintf(c_file, "    printf(\"RForth TURNKEY executable ready.\\n\");\n");
    
    fprintf(c_file, "    return 0;\n");
    fprintf(c_file, "}\n");
    
    fclose(c_file);
    
    /* Compile the C file */
#ifdef _WIN32
    /* Use cl.exe on Windows to compile the generated C file */
    char command[1024];
    snprintf(command, sizeof(command), "cl.exe /O2 /Fe:\"%s\" \"%s\"", output_file, c_filename);
    int result = system(command);
    if (result == 0) {
        io_printf("TURNKEY executable '%s' created successfully.\n", output_file);
        io_printf("Generated C code saved as: %s\n", c_filename);
        return true;
    } else {
        io_error_string("cl.exe compilation failed\n");
        return false;
    }
#else
    pid_t pid = fork();
    if (pid == -1) {
        io_error_string("Error: Failed to fork for compilation\n");
        return false;
    }

    if (pid == 0) {
        /* Child process - compile with gcc */
        char *args[] = {
            "gcc",
            "-O2",
            "-o",
            (char*)output_file,
            c_filename,
            NULL
        };

        execvp("gcc", args);
        io_error_string("Error: Failed to execute gcc\n");
        _exit(1);
    } else {
        /* Parent process - wait for compilation */
        int status;
        if (waitpid(pid, &status, 0) == -1) {
            io_error_string("Error: Failed to wait for gcc\n");
            return false;
        }

        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            io_printf("TURNKEY executable '%s' created successfully.\n", output_file);
            io_printf("Generated C code saved as: %s\n", c_filename);
            return true;
        } else {
            io_error_string("gcc compilation failed\n");
            return false;
        }
    }
#endif
}

void builtin_turnkey(rforth_ctx_t *ctx) {
    /* TURNKEY expects a filename on the stack */
    /* For now, we'll use a fixed filename - in a real implementation */
    /* this could be more sophisticated */
    
    if (!turnkey_create_executable(ctx, "turnkey_app")) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_COMPILE_ERROR, "TURNKEY failed");
        io_error_string("Error: TURNKEY failed\n");
    }
}