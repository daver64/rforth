#include "compiler.h"
#include "rforth.h"
#include <ctype.h>
#include <sys/wait.h>
#include <unistd.h>

/* Compiler context implementation */
struct compiler_ctx {
    FILE *output;               /* Output C file */
    char *output_filename;      /* Output C filename */
    char *executable_name;      /* Final executable name */
    int word_count;            /* Generated word counter */
    bool in_main;              /* Whether we're in main function */
};

/* Helper function to convert Forth word name to C identifier */
static void word_name_to_c_identifier(const char *forth_name, char *c_name, size_t size) {
    if (!forth_name || !c_name || size == 0) return;
    
    size_t i = 0, j = 0;
    while (forth_name[i] && j < size - 1) {
        if (forth_name[i] == '-') {
            c_name[j++] = '_';
        } else if (isalnum(forth_name[i])) {
            c_name[j++] = tolower(forth_name[i]);
        }
        /* Skip other characters */
        i++;
    }
    c_name[j] = '\0';
}

/* Helper function to generate word call code */
static void generate_word_call(FILE *output, const char *word_name) {
    /* Check if it's a builtin word */
    if (strcmp(word_name, "+") == 0) {
        fprintf(output, "    { int64_t b = pop(), a = pop(); push(a + b); }\n");
    } else if (strcmp(word_name, "-") == 0) {
        fprintf(output, "    { int64_t b = pop(), a = pop(); push(a - b); }\n");
    } else if (strcmp(word_name, "*") == 0) {
        fprintf(output, "    { int64_t b = pop(), a = pop(); push(a * b); }\n");
    } else if (strcmp(word_name, "/") == 0) {
        fprintf(output, "    { int64_t b = pop(), a = pop(); push(a / b); }\n");
    } else if (strcmp(word_name, ".") == 0) {
        fprintf(output, "    forth_dot();\n");
    } else if (strcmp(word_name, "emit") == 0) {
        fprintf(output, "    forth_emit();\n");
    } else if (strcmp(word_name, "cr") == 0) {
        fprintf(output, "    forth_cr();\n");
    } else if (strcmp(word_name, "dup") == 0) {
        fprintf(output, "    forth_dup();\n");
    } else if (strcmp(word_name, "drop") == 0) {
        fprintf(output, "    forth_drop();\n");
    } else if (strcmp(word_name, "swap") == 0) {
        fprintf(output, "    forth_swap();\n");
    } else {
        /* Assume it's a user word */
        char c_name[256];
        word_name_to_c_identifier(word_name, c_name, sizeof(c_name));
        fprintf(output, "    word_%s();\n", c_name);
    }
}



compiler_ctx_t* compiler_create(const char *output_file) {
    if (!output_file) return NULL;
    
    compiler_ctx_t *compiler = malloc(sizeof(compiler_ctx_t));
    if (!compiler) return NULL;
    
    /* Generate temporary C filename */
    compiler->output_filename = malloc(strlen(output_file) + 10);
    if (!compiler->output_filename) {
        free(compiler);
        return NULL;
    }
    snprintf(compiler->output_filename, strlen(output_file) + 10, "%s.c", output_file);
    
    /* Store executable name */
    compiler->executable_name = malloc(strlen(output_file) + 1);
    if (!compiler->executable_name) {
        free(compiler->output_filename);
        free(compiler);
        return NULL;
    }
    strncpy(compiler->executable_name, output_file, strlen(output_file));
    compiler->executable_name[strlen(output_file)] = '\0';
    
    /* Open output file */
    compiler->output = fopen(compiler->output_filename, "w");
    if (!compiler->output) {
        free(compiler->executable_name);
        free(compiler->output_filename);
        free(compiler);
        return NULL;
    }
    
    compiler->word_count = 0;
    compiler->in_main = false;
    
    return compiler;
}

void compiler_destroy(compiler_ctx_t *compiler) {
    if (compiler) {
        if (compiler->output) fclose(compiler->output);
        free(compiler->output_filename);
        free(compiler->executable_name);
        free(compiler);
    }
}

bool compiler_generate_header(compiler_ctx_t *compiler) {
    if (!compiler || !compiler->output) return false;
    
    fprintf(compiler->output, "/* Generated by RForth compiler */\n");
    fprintf(compiler->output, "#include <stdio.h>\n");
    fprintf(compiler->output, "#include <stdlib.h>\n");
    fprintf(compiler->output, "#include <stdint.h>\n\n");
    
    /* Runtime declarations */
    fprintf(compiler->output, "/* Runtime stack */\n");
    fprintf(compiler->output, "static int64_t stack[256];\n");
    fprintf(compiler->output, "static int sp = -1;\n\n");
    
    /* Runtime functions */
    fprintf(compiler->output, "static void push(int64_t value) {\n");
    fprintf(compiler->output, "    if (sp < 255) stack[++sp] = value;\n");
    fprintf(compiler->output, "}\n\n");
    
    fprintf(compiler->output, "static int64_t pop(void) {\n");
    fprintf(compiler->output, "    return (sp >= 0) ? stack[sp--] : 0;\n");
    fprintf(compiler->output, "}\n\n");
    
    fprintf(compiler->output, "static void forth_dot(void) {\n");
    fprintf(compiler->output, "    printf(\"%%ld \", (long)pop());\n");
    fprintf(compiler->output, "}\n\n");
    
    fprintf(compiler->output, "static void forth_emit(void) {\n");
    fprintf(compiler->output, "    printf(\"%%c\", (char)pop());\n");
    fprintf(compiler->output, "}\n\n");
    
    fprintf(compiler->output, "static void forth_cr(void) {\n");
    fprintf(compiler->output, "    printf(\"\\n\");\n");
    fprintf(compiler->output, "}\n\n");
    
    fprintf(compiler->output, "static void forth_dup(void) {\n");
    fprintf(compiler->output, "    if (sp >= 0) push(stack[sp]);\n");
    fprintf(compiler->output, "}\n\n");
    
    fprintf(compiler->output, "static void forth_drop(void) {\n");
    fprintf(compiler->output, "    if (sp >= 0) sp--;\n");
    fprintf(compiler->output, "}\n\n");
    
    fprintf(compiler->output, "static void forth_swap(void) {\n");
    fprintf(compiler->output, "    if (sp >= 1) {\n");
    fprintf(compiler->output, "        int64_t tmp = stack[sp];\n");
    fprintf(compiler->output, "        stack[sp] = stack[sp-1];\n");
    fprintf(compiler->output, "        stack[sp-1] = tmp;\n");
    fprintf(compiler->output, "    }\n");
    fprintf(compiler->output, "}\n\n");
    
    return true;
}

bool compiler_generate_word(compiler_ctx_t *compiler, const char *name, const char *definition) {
    if (!compiler || !compiler->output || !name || !definition) return false;
    
    /* Convert name to C-compatible identifier */
    char c_name[MAX_WORD_LENGTH];
    word_name_to_c_identifier(name, c_name, sizeof(c_name));
    
    fprintf(compiler->output, "/* User word: %s */\n", name);
    fprintf(compiler->output, "static void word_%s(void) {\n", c_name);
    
    /* Parse and compile the definition */
    parser_t *parser = parser_create();
    if (!parser) return false;
    
    parser_set_input(parser, definition);
    
    token_t token;
    while ((token = parser_next_token(parser)).type != TOKEN_EOF) {
        switch (token.type) {
            case TOKEN_NUMBER:
                fprintf(compiler->output, "    push(%ld);\n", (long)token.number);
                break;
                
            case TOKEN_WORD:
                generate_word_call(compiler->output, token.text);
                break;
                
            default:
                /* Skip other tokens */
                break;
        }
    }
    
    fprintf(compiler->output, "}\n\n");
    parser_destroy(parser);
    return true;
}

bool compiler_generate_main(compiler_ctx_t *compiler, const char *main_code) {
    if (!compiler || !compiler->output || !main_code) return false;
    
    fprintf(compiler->output, "int main(int argc, char *argv[]) {\n");
    fprintf(compiler->output, "    (void)argc; (void)argv;\n\n");
    
    /* Parse and compile the main code */
    parser_t *parser = parser_create();
    if (!parser) return false;
    
    parser_set_input(parser, main_code);
    
    token_t token;
    while ((token = parser_next_token(parser)).type != TOKEN_EOF) {
        switch (token.type) {
            case TOKEN_NUMBER:
                fprintf(compiler->output, "    push(%ld);\n", (long)token.number);
                break;
                
            case TOKEN_WORD:
                generate_word_call(compiler->output, token.text);
                break;
                
            default:
                /* Skip other tokens */
                break;
        }
    }
    
    fprintf(compiler->output, "\n    return 0;\n");
    fprintf(compiler->output, "}\n");
    
    parser_destroy(parser);
    return true;
}

bool compiler_generate_footer(compiler_ctx_t *compiler) {
    /* Nothing additional needed for footer */
    (void)compiler;
    return true;
}

bool compile_forth_to_c(const char *input_file, const char *output_file) {
    if (!input_file || !output_file) return false;
    
    /* Read the input file */
    FILE *file = fopen(input_file, "r");
    if (!file) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", input_file);
        return false;
    }
    
    /* Read entire file into memory */
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    char *content = malloc(size + 1);
    if (!content) {
        fclose(file);
        return false;
    }
    
    size_t read_size = fread(content, 1, size, file);
    content[read_size] = '\0';
    fclose(file);
    
    /* Create compiler context */
    compiler_ctx_t *compiler = compiler_create(output_file);
    if (!compiler) {
        free(content);
        return false;
    }
    
    /* Generate header */
    if (!compiler_generate_header(compiler)) {
        compiler_destroy(compiler);
        free(content);
        return false;
    }
    
    /* Parse the content and separate word definitions from main code */
    parser_t *parser = parser_create();
    if (!parser) {
        compiler_destroy(compiler);
        free(content);
        return false;
    }
    
    parser_set_input(parser, content);
    
    /* First pass: collect word definitions */
    token_t token;
    while ((token = parser_next_token(parser)).type != TOKEN_EOF) {
        if (token.type == TOKEN_COLON) {
            /* Word definition */
            token_t name_token = parser_next_token(parser);
            if (name_token.type != TOKEN_WORD) {
                fprintf(stderr, "Error: Expected word name after ':'\n");
                parser_destroy(parser);
                compiler_destroy(compiler);
                free(content);
                return false;
            }
            
            /* Collect definition until semicolon */
            char definition[1024] = "";
            int def_pos = 0;
            
            while ((token = parser_next_token(parser)).type != TOKEN_EOF) {
                if (token.type == TOKEN_SEMICOLON) {
                    break;
                }
                
                /* Add token to definition */
                if (def_pos > 0 && def_pos < (int)(sizeof(definition) - 2)) {
                    definition[def_pos++] = ' ';
                }
                
                const char *token_text = NULL;
                char number_str[32];
                
                if (token.type == TOKEN_NUMBER) {
                    snprintf(number_str, sizeof(number_str), "%ld", (long)token.number);
                    token_text = number_str;
                } else if (token.type == TOKEN_WORD) {
                    token_text = token.text;
                }
                
                if (token_text) {
                    int len = strlen(token_text);
                    if (def_pos + len < (int)(sizeof(definition) - 1)) {
                        strcpy(definition + def_pos, token_text);
                        def_pos += len;
                    }
                }
            }
            
            definition[def_pos] = '\0';
            
            /* Generate the word function */
            if (!compiler_generate_word(compiler, name_token.text, definition)) {
                parser_destroy(parser);
                compiler_destroy(compiler);
                free(content);
                return false;
            }
        }
    }
    
    /* Second pass: collect main code (everything not in word definitions) */
    parser_set_input(parser, content);
    char main_code[2048] = "";
    int main_pos = 0;
    bool in_definition = false;
    
    while ((token = parser_next_token(parser)).type != TOKEN_EOF) {
        if (token.type == TOKEN_COLON) {
            in_definition = true;
        } else if (token.type == TOKEN_SEMICOLON) {
            in_definition = false;
        } else if (!in_definition && token.type != TOKEN_COMMENT_START) {
            /* Add to main code */
            if (main_pos > 0 && main_pos < (int)(sizeof(main_code) - 2)) {
                main_code[main_pos++] = ' ';
            }
            
            const char *token_text = NULL;
            char number_str[32];
            
            if (token.type == TOKEN_NUMBER) {
                snprintf(number_str, sizeof(number_str), "%ld", (long)token.number);
                token_text = number_str;
            } else if (token.type == TOKEN_WORD) {
                token_text = token.text;
            }
            
            if (token_text) {
                int len = strlen(token_text);
                if (main_pos + len < (int)(sizeof(main_code) - 1)) {
                    strcpy(main_code + main_pos, token_text);
                    main_pos += len;
                }
            }
        }
    }
    
    main_code[main_pos] = '\0';
    
    /* Generate main function */
    if (!compiler_generate_main(compiler, main_code)) {
        parser_destroy(parser);
        compiler_destroy(compiler);
        free(content);
        return false;
    }
    
    /* Generate footer */
    compiler_generate_footer(compiler);
    
    /* Compile the C code */
    char *c_filename = compiler->output_filename;
    char *exe_filename = compiler->executable_name;
    
    /* Close the file before compiling */
    fclose(compiler->output);
    compiler->output = NULL;
    
    bool compile_success = invoke_c_compiler(c_filename, exe_filename);
    
    /* Cleanup */
    if (compile_success) {
        /* Keep C file for debugging - comment out to remove */
        /* unlink(c_filename); */
        printf("Generated C code saved as: %s\n", c_filename);
    }
    
    parser_destroy(parser);
    compiler_destroy(compiler);
    free(content);
    
    return compile_success;
}

bool invoke_c_compiler(const char *c_file, const char *output_file) {
    if (!c_file || !output_file) return false;
    
    /* Validate file paths to prevent injection */
    if (strstr(c_file, "..") || strstr(output_file, "..") ||
        strchr(c_file, ';') || strchr(output_file, ';') ||
        strchr(c_file, '&') || strchr(output_file, '&') ||
        strchr(c_file, '|') || strchr(output_file, '|')) {
        fprintf(stderr, "Error: Invalid characters in file paths\n");
        return false;
    }
    
    /* Fork and exec gcc safely */
    pid_t pid = fork();
    if (pid == -1) {
        fprintf(stderr, "Error: Failed to fork process\n");
        return false;
    }
    
    if (pid == 0) {
        /* Child process - exec gcc */
        char *args[] = {
            "gcc",
            "-O2",
            "-o",
            (char*)output_file,
            (char*)c_file,
            NULL
        };
        
        execvp("gcc", args);
        /* If we get here, exec failed */
        fprintf(stderr, "Error: Failed to execute gcc\n");
        _exit(1);
    } else {
        /* Parent process - wait for child */
        int status;
        if (waitpid(pid, &status, 0) == -1) {
            fprintf(stderr, "Error: Failed to wait for gcc process\n");
            return false;
        }
        
        if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {
            return true;
        } else {
            fprintf(stderr, "gcc compilation failed (exit code: %d)\n", 
                    WIFEXITED(status) ? WEXITSTATUS(status) : -1);
            return false;
        }
    }
}