#include "rforth.h"
#include "turnkey.h"
#include <stdio.h>

/* Forward declarations */
static void builtin_add(rforth_ctx_t *ctx);
static void builtin_sub(rforth_ctx_t *ctx);
static void builtin_mul(rforth_ctx_t *ctx);
static void builtin_div(rforth_ctx_t *ctx);
static void builtin_mod(rforth_ctx_t *ctx);
static void builtin_dup(rforth_ctx_t *ctx);
static void builtin_drop(rforth_ctx_t *ctx);
static void builtin_swap(rforth_ctx_t *ctx);
static void builtin_over(rforth_ctx_t *ctx);
static void builtin_rot(rforth_ctx_t *ctx);
static void builtin_dot(rforth_ctx_t *ctx);
static void builtin_emit(rforth_ctx_t *ctx);
static void builtin_cr(rforth_ctx_t *ctx);
static void builtin_space(rforth_ctx_t *ctx);
static void builtin_words_cmd(rforth_ctx_t *ctx);
static void builtin_bye(rforth_ctx_t *ctx);
static void builtin_equal(rforth_ctx_t *ctx);
static void builtin_less(rforth_ctx_t *ctx);
static void builtin_greater(rforth_ctx_t *ctx);
static void builtin_and(rforth_ctx_t *ctx);
static void builtin_or(rforth_ctx_t *ctx);
static void builtin_not(rforth_ctx_t *ctx);
static void builtin_negate(rforth_ctx_t *ctx);

/* Structure to hold builtin word definitions */
typedef struct {
    const char *name;
    void (*func)(rforth_ctx_t *ctx);
} builtin_word_t;

/* Table of builtin words */
static const builtin_word_t builtin_words[] = {
    /* Arithmetic */
    {"+", builtin_add},
    {"-", builtin_sub},
    {"*", builtin_mul},
    {"/", builtin_div},
    {"mod", builtin_mod},
    {"negate", builtin_negate},
    
    /* Stack manipulation */
    {"dup", builtin_dup},
    {"drop", builtin_drop},
    {"swap", builtin_swap},
    {"over", builtin_over},
    {"rot", builtin_rot},
    
    /* I/O */
    {".", builtin_dot},
    {"emit", builtin_emit},
    {"cr", builtin_cr},
    {"space", builtin_space},
    
    /* Comparison */
    {"=", builtin_equal},
    {"<", builtin_less},
    {">", builtin_greater},
    
    /* Logic */
    {"and", builtin_and},
    {"or", builtin_or},
    {"not", builtin_not},
    
    /* System */
    {".s", builtin_dot_s},
    {"words", builtin_words_cmd},
    {"bye", builtin_bye},
    {"turnkey", builtin_turnkey},
    
    /* End marker */
    {NULL, NULL}
};

bool builtins_register(dict_t *dict) {
    if (!dict) return false;
    
    for (int i = 0; builtin_words[i].name; i++) {
        if (!dict_add_builtin(dict, builtin_words[i].name, builtin_words[i].func)) {
            return false;
        }
    }
    
    return true;
}

/* Builtin implementations */

static void builtin_add(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    
    /* If either operand is float, do floating point arithmetic */
    if (a.type == CELL_FLOAT || b.type == CELL_FLOAT) {
        double result = cell_to_float(&a) + cell_to_float(&b);
        stack_push_float(ctx->data_stack, result);
    } else {
        int64_t result = a.value.i + b.value.i;
        stack_push_int(ctx->data_stack, result);
    }
}

static void builtin_sub(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    
    /* If either operand is float, do floating point arithmetic */
    if (a.type == CELL_FLOAT || b.type == CELL_FLOAT) {
        double result = cell_to_float(&a) - cell_to_float(&b);
        stack_push_float(ctx->data_stack, result);
    } else {
        int64_t result = a.value.i - b.value.i;
        stack_push_int(ctx->data_stack, result);
    }
}

static void builtin_mul(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, a * b);
}

static void builtin_div(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    if (b == 0) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_DIVISION_BY_ZERO, "Division by zero");
        return;
    }
    stack_push(ctx->data_stack, a / b);
}

static void builtin_mod(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    if (b == 0) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_DIVISION_BY_ZERO, "Division by zero");
        return;
    }
    stack_push(ctx->data_stack, a % b);
}

static void builtin_negate(rforth_ctx_t *ctx) {
    cell_t a;
    if (!stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, -a);
}

static void builtin_dup(rforth_ctx_t *ctx) {
    if (!stack_dup(ctx->data_stack)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
    }
}

static void builtin_drop(rforth_ctx_t *ctx) {
    if (!stack_drop(ctx->data_stack)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
    }
}

static void builtin_swap(rforth_ctx_t *ctx) {
    if (!stack_swap(ctx->data_stack)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
    }
}

static void builtin_over(rforth_ctx_t *ctx) {
    if (!stack_over(ctx->data_stack)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
    }
}

static void builtin_rot(rforth_ctx_t *ctx) {
    if (!stack_rot(ctx->data_stack)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
    }
}

static void builtin_dot(rforth_ctx_t *ctx) {
    cell_t value;
    if (!stack_pop(ctx->data_stack, &value)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    printf("%ld ", (long)value);
}

static void builtin_emit(rforth_ctx_t *ctx) {
    cell_t value;
    if (!stack_pop(ctx->data_stack, &value)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    printf("%c", (char)value);
}

static void builtin_cr(rforth_ctx_t *ctx) {
    (void)ctx; /* Unused */
    printf("\n");
}

static void builtin_space(rforth_ctx_t *ctx) {
    (void)ctx; /* Unused */
    printf(" ");
}

void builtin_dot_s(rforth_ctx_t *ctx) {
    printf("<%d> ", stack_depth(ctx->data_stack));
    if (!stack_is_empty(ctx->data_stack)) {
        stack_print(ctx->data_stack);
    } else {
        printf("\n");
    }
}

static void builtin_words_cmd(rforth_ctx_t *ctx) {
    dict_print(ctx->dict);
}

static void builtin_bye(rforth_ctx_t *ctx) {
    ctx->running = false;
}

static void builtin_equal(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, (a == b) ? -1 : 0);
}

static void builtin_less(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, (a < b) ? -1 : 0);
}

static void builtin_greater(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, (a > b) ? -1 : 0);
}

static void builtin_and(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, a & b);
}

static void builtin_or(rforth_ctx_t *ctx) {
    cell_t b, a;
    if (!stack_pop(ctx->data_stack, &b) || !stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, a | b);
}

static void builtin_not(rforth_ctx_t *ctx) {
    cell_t a;
    if (!stack_pop(ctx->data_stack, &a)) {
        RFORTH_SET_ERROR(ctx, RFORTH_ERROR_STACK_UNDERFLOW, "Stack underflow");
        return;
    }
    stack_push(ctx->data_stack, ~a);
}